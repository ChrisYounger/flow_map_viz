{"version":3,"file":"prepare.min.js","sources":["../src/settings.js","../src/CountLimiter.js","../src/BasePrepare.js","../src/Prepare.js","../src/TimeLimiter.js"],"sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\nsettings.UPLOADS_PER_FRAME = 4;\n\nexport { settings };\n","/**\n * CountLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of items per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class CountLimiter\n{\n    /**\n     * @param {number} maxItemsPerFrame - The maximum number of items that can be prepared each frame.\n     */\n    constructor(maxItemsPerFrame)\n    {\n        /**\n         * The maximum number of items that can be prepared each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxItemsPerFrame = maxItemsPerFrame;\n        /**\n         * The number of items that can be prepared in the current frame.\n         * @type {number}\n         * @private\n         */\n        this.itemsLeft = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.itemsLeft = this.maxItemsPerFrame;\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return this.itemsLeft-- > 0;\n    }\n}\n","import { Texture, BaseTexture } from '@pixi/core';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { settings } from '@pixi/settings';\nimport { Container } from '@pixi/display';\nimport { Text, TextStyle, TextMetrics } from '@pixi/text';\nimport { CountLimiter } from './CountLimiter';\n\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI\n */\nexport class BasePrepare\n{\n    /**\n     * @param {PIXI.AbstractRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.CountLimiter|PIXI.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.AbstractRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and Prepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {object}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n     *        Either the container or display object to search for items to upload, the items to upload themselves,\n     *        or the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     *\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerFindHook(addHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     *\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook)\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @return {this} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get children recursively\n        if (item instanceof Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            Ticker.system.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue)\n{\n    let result = false;\n\n    // Objects with multiple textures\n    if (item && item._textures && item._textures.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (queue.indexOf(baseTexture) === -1)\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Texture.\n *\n * @private\n * @param {PIXI.Texture} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue)\n{\n    if (item.baseTexture instanceof BaseTexture)\n    {\n        const texture = item.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue)\n{\n    if (item._texture && item._texture instanceof Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof TextStyle)\n    {\n        const font = item.toFontString();\n\n        TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n","import { BaseTexture } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { BasePrepare } from './BasePrepare';\n\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new application\n * const app = new PIXI.Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new PIXI.Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n *\n * @class\n * @extends PIXI.BasePrepare\n * @memberof PIXI\n */\nexport class Prepare extends BasePrepare\n{\n    /**\n     * @param {PIXI.Renderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.uploadHookHelper = this.renderer;\n\n        // Add textures and graphics to upload\n        this.registerFindHook(findGraphics);\n        this.registerUploadHook(uploadBaseTextures);\n        this.registerUploadHook(uploadGraphics);\n    }\n}\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.BaseTexture} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadBaseTextures(renderer, item)\n{\n    if (item instanceof BaseTexture)\n    {\n        // if the texture already has a GL texture, then the texture has been prepared or rendered\n        // before now. If the texture changed, then the changer should be calling texture.update() which\n        // reuploads the texture without need for preparing it again\n        if (!item._glTextures[renderer.CONTEXT_UID])\n        {\n            renderer.texture.bind(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadGraphics(renderer, item)\n{\n    if (!(item instanceof Graphics))\n    {\n        return false;\n    }\n\n    const { geometry } = item;\n\n    // update dirty graphics to get batches\n    item.finishPoly();\n    geometry.updateBatches();\n\n    const { batches } = geometry;\n\n    // upload all textures found in styles\n    for (let i = 0; i < batches.length; i++)\n    {\n        const { texture } = batches[i].style;\n\n        if (texture)\n        {\n            uploadBaseTextures(renderer, texture.baseTexture);\n        }\n    }\n\n    // if its not batchable - update vao for particular shader\n    if (!geometry.batchable)\n    {\n        renderer.geometry.bind(geometry, item._resolveDirectShader());\n    }\n\n    return true;\n}\n\n/**\n * Built-in hook to find graphics.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item, queue)\n{\n    if (item instanceof Graphics)\n    {\n        queue.push(item);\n\n        return true;\n    }\n\n    return false;\n}\n","/**\n * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of milliseconds per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class TimeLimiter\n{\n    /**\n     * @param {number} maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame.\n     */\n    constructor(maxMilliseconds)\n    {\n        /**\n         * The maximum milliseconds that can be spent preparing items each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxMilliseconds = maxMilliseconds;\n        /**\n         * The start time of the current frame.\n         * @type {number}\n         * @private\n         */\n        this.frameStart = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.frameStart = Date.now();\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return Date.now() - this.frameStart < this.maxMilliseconds;\n    }\n}\n"],"names":["UPLOADS_PER_FRAME","CountLimiter","maxItemsPerFrame","this","itemsLeft","beginFrame","allowedToUpload","BasePrepare","renderer","limiter","settings","uploadHookHelper","queue","addHooks","uploadHooks","completes","ticking","delayedTick","prepareItems","registerFindHook","findText","findTextStyle","findMultipleBaseTextures","findBaseTexture","findTexture","registerUploadHook","drawText","calculateTextStyle","item","let","result","_textures","length","i","Texture","const","baseTexture","indexOf","push","BaseTexture","texture","_texture","helper","Text","updateText","TextStyle","font","toFontString","TextMetrics","measureFont","style","upload","done","add","Ticker","system","addOnce","tick","UPDATE_PRIORITY","UTILITY","setTimeout","uploaded","_destroyed","len","shift","slice","addHook","uploadHook","Container","children","destroy","remove","Prepare","super","findGraphics","uploadBaseTextures","uploadGraphics","_glTextures","CONTEXT_UID","bind","Graphics","finishPoly","geometry","updateBatches","batches","batchable","_resolveDirectShader","TimeLimiter","maxMilliseconds","frameStart","Date","now"],"mappings":"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"}