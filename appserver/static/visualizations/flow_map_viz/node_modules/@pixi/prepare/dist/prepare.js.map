{"version":3,"file":"prepare.js","sources":["../src/settings.js","../src/CountLimiter.js","../src/BasePrepare.js","../src/Prepare.js","../src/TimeLimiter.js"],"sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\nsettings.UPLOADS_PER_FRAME = 4;\n\nexport { settings };\n","/**\n * CountLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of items per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class CountLimiter\n{\n    /**\n     * @param {number} maxItemsPerFrame - The maximum number of items that can be prepared each frame.\n     */\n    constructor(maxItemsPerFrame)\n    {\n        /**\n         * The maximum number of items that can be prepared each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxItemsPerFrame = maxItemsPerFrame;\n        /**\n         * The number of items that can be prepared in the current frame.\n         * @type {number}\n         * @private\n         */\n        this.itemsLeft = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.itemsLeft = this.maxItemsPerFrame;\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return this.itemsLeft-- > 0;\n    }\n}\n","import { Texture, BaseTexture } from '@pixi/core';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { settings } from '@pixi/settings';\nimport { Container } from '@pixi/display';\nimport { Text, TextStyle, TextMetrics } from '@pixi/text';\nimport { CountLimiter } from './CountLimiter';\n\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI\n */\nexport class BasePrepare\n{\n    /**\n     * @param {PIXI.AbstractRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.CountLimiter|PIXI.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.AbstractRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and Prepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {object}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n     *        Either the container or display object to search for items to upload, the items to upload themselves,\n     *        or the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     *\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerFindHook(addHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     *\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook)\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @return {this} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get children recursively\n        if (item instanceof Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            Ticker.system.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue)\n{\n    let result = false;\n\n    // Objects with multiple textures\n    if (item && item._textures && item._textures.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (queue.indexOf(baseTexture) === -1)\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Texture.\n *\n * @private\n * @param {PIXI.Texture} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue)\n{\n    if (item.baseTexture instanceof BaseTexture)\n    {\n        const texture = item.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue)\n{\n    if (item._texture && item._texture instanceof Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof TextStyle)\n    {\n        const font = item.toFontString();\n\n        TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n","import { BaseTexture } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { BasePrepare } from './BasePrepare';\n\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new application\n * const app = new PIXI.Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new PIXI.Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n *\n * @class\n * @extends PIXI.BasePrepare\n * @memberof PIXI\n */\nexport class Prepare extends BasePrepare\n{\n    /**\n     * @param {PIXI.Renderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.uploadHookHelper = this.renderer;\n\n        // Add textures and graphics to upload\n        this.registerFindHook(findGraphics);\n        this.registerUploadHook(uploadBaseTextures);\n        this.registerUploadHook(uploadGraphics);\n    }\n}\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.BaseTexture} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadBaseTextures(renderer, item)\n{\n    if (item instanceof BaseTexture)\n    {\n        // if the texture already has a GL texture, then the texture has been prepared or rendered\n        // before now. If the texture changed, then the changer should be calling texture.update() which\n        // reuploads the texture without need for preparing it again\n        if (!item._glTextures[renderer.CONTEXT_UID])\n        {\n            renderer.texture.bind(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadGraphics(renderer, item)\n{\n    if (!(item instanceof Graphics))\n    {\n        return false;\n    }\n\n    const { geometry } = item;\n\n    // update dirty graphics to get batches\n    item.finishPoly();\n    geometry.updateBatches();\n\n    const { batches } = geometry;\n\n    // upload all textures found in styles\n    for (let i = 0; i < batches.length; i++)\n    {\n        const { texture } = batches[i].style;\n\n        if (texture)\n        {\n            uploadBaseTextures(renderer, texture.baseTexture);\n        }\n    }\n\n    // if its not batchable - update vao for particular shader\n    if (!geometry.batchable)\n    {\n        renderer.geometry.bind(geometry, item._resolveDirectShader());\n    }\n\n    return true;\n}\n\n/**\n * Built-in hook to find graphics.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item, queue)\n{\n    if (item instanceof Graphics)\n    {\n        queue.push(item);\n\n        return true;\n    }\n\n    return false;\n}\n","/**\n * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of milliseconds per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class TimeLimiter\n{\n    /**\n     * @param {number} maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame.\n     */\n    constructor(maxMilliseconds)\n    {\n        /**\n         * The maximum milliseconds that can be spent preparing items each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxMilliseconds = maxMilliseconds;\n        /**\n         * The start time of the current frame.\n         * @type {number}\n         * @private\n         */\n        this.frameStart = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.frameStart = Date.now();\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return Date.now() - this.frameStart < this.maxMilliseconds;\n    }\n}\n"],"names":["settings","this","Ticker","UPDATE_PRIORITY","let","const","i","len","Container","Texture","BaseTexture","Text","TextStyle","TextMetrics","super","Graphics"],"mappings":"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"}