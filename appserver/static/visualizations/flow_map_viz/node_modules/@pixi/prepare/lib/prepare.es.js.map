{"version":3,"file":"prepare.es.js","sources":["../src/settings.js","../src/CountLimiter.js","../src/BasePrepare.js","../src/Prepare.js","../src/TimeLimiter.js"],"sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\nsettings.UPLOADS_PER_FRAME = 4;\n\nexport { settings };\n","/**\n * CountLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of items per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class CountLimiter\n{\n    /**\n     * @param {number} maxItemsPerFrame - The maximum number of items that can be prepared each frame.\n     */\n    constructor(maxItemsPerFrame)\n    {\n        /**\n         * The maximum number of items that can be prepared each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxItemsPerFrame = maxItemsPerFrame;\n        /**\n         * The number of items that can be prepared in the current frame.\n         * @type {number}\n         * @private\n         */\n        this.itemsLeft = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.itemsLeft = this.maxItemsPerFrame;\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return this.itemsLeft-- > 0;\n    }\n}\n","import { Texture, BaseTexture } from '@pixi/core';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { settings } from '@pixi/settings';\nimport { Container } from '@pixi/display';\nimport { Text, TextStyle, TextMetrics } from '@pixi/text';\nimport { CountLimiter } from './CountLimiter';\n\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI\n */\nexport class BasePrepare\n{\n    /**\n     * @param {PIXI.AbstractRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.CountLimiter|PIXI.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.AbstractRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and Prepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {object}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n     *        Either the container or display object to search for items to upload, the items to upload themselves,\n     *        or the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     *\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerFindHook(addHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     *\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @return {this} Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook)\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @return {this} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get children recursively\n        if (item instanceof Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            Ticker.system.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue)\n{\n    let result = false;\n\n    // Objects with multiple textures\n    if (item && item._textures && item._textures.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (queue.indexOf(baseTexture) === -1)\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Texture.\n *\n * @private\n * @param {PIXI.Texture} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue)\n{\n    if (item.baseTexture instanceof BaseTexture)\n    {\n        const texture = item.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue)\n{\n    if (item._texture && item._texture instanceof Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof TextStyle)\n    {\n        const font = item.toFontString();\n\n        TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n","import { BaseTexture } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { BasePrepare } from './BasePrepare';\n\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new application\n * const app = new PIXI.Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new PIXI.Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n *\n * @class\n * @extends PIXI.BasePrepare\n * @memberof PIXI\n */\nexport class Prepare extends BasePrepare\n{\n    /**\n     * @param {PIXI.Renderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.uploadHookHelper = this.renderer;\n\n        // Add textures and graphics to upload\n        this.registerFindHook(findGraphics);\n        this.registerUploadHook(uploadBaseTextures);\n        this.registerUploadHook(uploadGraphics);\n    }\n}\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.BaseTexture} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadBaseTextures(renderer, item)\n{\n    if (item instanceof BaseTexture)\n    {\n        // if the texture already has a GL texture, then the texture has been prepared or rendered\n        // before now. If the texture changed, then the changer should be calling texture.update() which\n        // reuploads the texture without need for preparing it again\n        if (!item._glTextures[renderer.CONTEXT_UID])\n        {\n            renderer.texture.bind(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n *\n * @private\n * @param {PIXI.Renderer} renderer - instance of the webgl renderer\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction uploadGraphics(renderer, item)\n{\n    if (!(item instanceof Graphics))\n    {\n        return false;\n    }\n\n    const { geometry } = item;\n\n    // update dirty graphics to get batches\n    item.finishPoly();\n    geometry.updateBatches();\n\n    const { batches } = geometry;\n\n    // upload all textures found in styles\n    for (let i = 0; i < batches.length; i++)\n    {\n        const { texture } = batches[i].style;\n\n        if (texture)\n        {\n            uploadBaseTextures(renderer, texture.baseTexture);\n        }\n    }\n\n    // if its not batchable - update vao for particular shader\n    if (!geometry.batchable)\n    {\n        renderer.geometry.bind(geometry, item._resolveDirectShader());\n    }\n\n    return true;\n}\n\n/**\n * Built-in hook to find graphics.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item, queue)\n{\n    if (item instanceof Graphics)\n    {\n        queue.push(item);\n\n        return true;\n    }\n\n    return false;\n}\n","/**\n * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of milliseconds per frame.\n *\n * @class\n * @memberof PIXI\n */\nexport class TimeLimiter\n{\n    /**\n     * @param {number} maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame.\n     */\n    constructor(maxMilliseconds)\n    {\n        /**\n         * The maximum milliseconds that can be spent preparing items each frame.\n         * @type {number}\n         * @private\n         */\n        this.maxMilliseconds = maxMilliseconds;\n        /**\n         * The start time of the current frame.\n         * @type {number}\n         * @private\n         */\n        this.frameStart = 0;\n    }\n\n    /**\n     * Resets any counting properties to start fresh on a new frame.\n     */\n    beginFrame()\n    {\n        this.frameStart = Date.now();\n    }\n\n    /**\n     * Checks to see if another item can be uploaded. This should only be called once per item.\n     * @return {boolean} If the item is allowed to be uploaded.\n     */\n    allowedToUpload()\n    {\n        return Date.now() - this.frameStart < this.maxMilliseconds;\n    }\n}\n"],"names":["this","let","const","i","len","super"],"mappings":"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"}