{"version":3,"file":"spritesheet.js","sources":["../src/Spritesheet.js","../src/SpritesheetLoader.js"],"sourcesContent":["import { Rectangle } from '@pixi/math';\nimport { Texture } from '@pixi/core';\nimport { getResolutionOfUrl } from '@pixi/utils';\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    static get BATCH_SIZE()\n    {\n        return 1000;\n    }\n\n    /**\n     * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(baseTexture, data, resolutionFilename = null)\n    {\n        /**\n         * Reference to ths source texture\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(\n            resolutionFilename\n            || (this.baseTexture.resource ? this.baseTexture.resource.url : null)\n        );\n\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    _updateResolution(resolutionFilename)\n    {\n        const scale = this.data.meta.scale;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.setResolution(resolution);\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    parse(callback)\n    {\n        this._batchIndex = 0;\n        this._callback = callback;\n\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n        {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else\n        {\n            this._nextBatch();\n        }\n    }\n\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    _processFrames(initialFrameIndex)\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    _processAnimations()\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    _parseComplete()\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    _nextBatch()\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase = false)\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this.baseTexture.destroy();\n        }\n        this.baseTexture = null;\n    }\n}\n","import { url } from '@pixi/utils';\nimport { LoaderResource } from '@pixi/loaders';\nimport { Spritesheet } from './Spritesheet';\n\n/**\n * {@link PIXI.Loader Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\nexport class SpritesheetLoader\n{\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param {PIXI.LoaderResource} resource\n     * @param {function} next\n     */\n    static use(resource, next)\n    {\n        const imageResourceName = `${resource.name}_image`;\n\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data\n            || resource.type !== LoaderResource.TYPE.JSON\n            || !resource.data.frames\n            || this.resources[imageResourceName]\n        )\n        {\n            next();\n\n            return;\n        }\n\n        const loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata.imageMetadata,\n            parentResource: resource,\n        };\n\n        const resourcePath = SpritesheetLoader.getResourcePath(resource, this.baseUrl);\n\n        // load the image for this sheet\n        this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res)\n        {\n            if (res.error)\n            {\n                next(res.error);\n\n                return;\n            }\n\n            const spritesheet = new Spritesheet(\n                res.texture.baseTexture,\n                resource.data,\n                resource.url\n            );\n\n            spritesheet.parse(() =>\n            {\n                resource.spritesheet = spritesheet;\n                resource.textures = spritesheet.textures;\n                next();\n            });\n        });\n    }\n\n    /**\n     * Get the spritesheets root path\n     * @param {PIXI.LoaderResource} resource - Resource to check path\n     * @param {string} baseUrl - Base root url\n     */\n    static getResourcePath(resource, baseUrl)\n    {\n        // Prepend url path unless the resource image is a data url\n        if (resource.isDataUrl)\n        {\n            return resource.data.meta.image;\n        }\n\n        return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n    }\n}\n"],"names":["getResolutionOfUrl","let","const","Rectangle","Texture","this","LoaderResource","url"],"mappings":"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"}