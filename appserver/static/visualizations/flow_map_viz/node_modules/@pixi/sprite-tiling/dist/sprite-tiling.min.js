/*!
 * @pixi/sprite-tiling - v5.2.1
 * Compiled Tue, 28 Jan 2020 23:33:11 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI=this.PIXI||{};var _pixi_sprite_tiling=function(t,r,e,i,o,n){"use strict";var a=new e.Point,s=function(t){function o(i,o,n){void 0===o&&(o=100),void 0===n&&(n=100),t.call(this,i),this.tileTransform=new e.Transform,this._width=o,this._height=n,this._canvasPattern=null,this.uvMatrix=i.uvMatrix||new r.TextureMatrix(i),this.pluginName="tilingSprite",this.uvRespectAnchor=!1}t&&(o.__proto__=t),o.prototype=Object.create(t&&t.prototype),o.prototype.constructor=o;var n={clampMargin:{configurable:!0},tileScale:{configurable:!0},tilePosition:{configurable:!0},width:{configurable:!0},height:{configurable:!0}};return n.clampMargin.get=function(){return this.uvMatrix.clampMargin},n.clampMargin.set=function(t){this.uvMatrix.clampMargin=t,this.uvMatrix.update(!0)},n.tileScale.get=function(){return this.tileTransform.scale},n.tileScale.set=function(t){this.tileTransform.scale.copyFrom(t)},n.tilePosition.get=function(){return this.tileTransform.position},n.tilePosition.set=function(t){this.tileTransform.position.copyFrom(t)},o.prototype._onTextureUpdate=function(){this.uvMatrix&&(this.uvMatrix.texture=this._texture),this._cachedTint=16777215},o.prototype._render=function(t){var r=this._texture;r&&r.valid&&(this.tileTransform.updateLocalTransform(),this.uvMatrix.update(),t.batch.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this))},o.prototype._calculateBounds=function(){var t=this._width*-this._anchor._x,r=this._height*-this._anchor._y,e=this._width*(1-this._anchor._x),i=this._height*(1-this._anchor._y);this._bounds.addFrame(this.transform,t,r,e,i)},o.prototype.getLocalBounds=function(r){return 0===this.children.length?(this._bounds.minX=this._width*-this._anchor._x,this._bounds.minY=this._height*-this._anchor._y,this._bounds.maxX=this._width*(1-this._anchor._x),this._bounds.maxY=this._height*(1-this._anchor._y),r||(this._localBoundsRect||(this._localBoundsRect=new e.Rectangle),r=this._localBoundsRect),this._bounds.getRectangle(r)):t.prototype.getLocalBounds.call(this,r)},o.prototype.containsPoint=function(t){this.worldTransform.applyInverse(t,a);var r=this._width,e=this._height,i=-r*this.anchor._x;if(a.x>=i&&a.x<i+r){var o=-e*this.anchor._y;if(a.y>=o&&a.y<o+e)return!0}return!1},o.prototype.destroy=function(r){t.prototype.destroy.call(this,r),this.tileTransform=null,this.uvMatrix=null},o.from=function(t,e,i){return new o(r.Texture.from(t),e,i)},o.fromFrame=function(t,r,e){var n=i.TextureCache[t];if(!n)throw new Error('The frameId "'+t+'" does not exist in the texture cache '+this);return new o(n,r,e)},o.fromImage=function(t,e,i,n){return n&&"object"!=typeof n&&(n={scaleMode:arguments[4],resourceOptions:{crossorigin:arguments[3]}}),new o(r.Texture.from(t,n),e,i)},n.width.get=function(){return this._width},n.width.set=function(t){this._width=t},n.height.get=function(){return this._height},n.height.set=function(t){this._height=t},Object.defineProperties(o.prototype,n),o}(o.Sprite),h="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",u="varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord - floor(vTextureCoord - uClampOffset);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n",c="varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n",l=new e.Matrix,d=function(t){function e(e){t.call(this,e);var i={globals:this.renderer.globalUniforms};this.shader=r.Shader.from(h,u,i),this.simpleShader=r.Shader.from(h,c,i),this.quad=new r.QuadUv,this.state=r.State.for2d()}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.render=function(t){var r=this.renderer,e=this.quad,o=e.vertices;o[0]=o[6]=t._width*-t.anchor.x,o[1]=o[3]=t._height*-t.anchor.y,o[2]=o[4]=t._width*(1-t.anchor.x),o[5]=o[7]=t._height*(1-t.anchor.y),t.uvRespectAnchor&&((o=e.uvs)[0]=o[6]=-t.anchor.x,o[1]=o[3]=-t.anchor.y,o[2]=o[4]=1-t.anchor.x,o[5]=o[7]=1-t.anchor.y),e.invalidate();var a=t._texture,s=a.baseTexture,h=t.tileTransform.localTransform,u=t.uvMatrix,c=s.isPowerOfTwo&&a.frame.width===s.width&&a.frame.height===s.height;c&&(s._glTextures[r.CONTEXT_UID]?c=s.wrapMode!==n.WRAP_MODES.CLAMP:s.wrapMode===n.WRAP_MODES.CLAMP&&(s.wrapMode=n.WRAP_MODES.REPEAT));var d=c?this.simpleShader:this.shader,p=a.width,m=a.height,f=t._width,_=t._height;l.set(h.a*p/f,h.b*p/_,h.c*m/f,h.d*m/_,h.tx/f,h.ty/_),l.invert(),c?l.prepend(u.mapCoord):(d.uniforms.uMapCoord=u.mapCoord.toArray(!0),d.uniforms.uClampFrame=u.uClampFrame,d.uniforms.uClampOffset=u.uClampOffset),d.uniforms.uTransform=l.toArray(!0),d.uniforms.uColor=i.premultiplyTintToRgba(t.tint,t.worldAlpha,d.uniforms.uColor,s.alphaMode),d.uniforms.translationMatrix=t.transform.worldTransform.toArray(!0),d.uniforms.uSampler=a,r.shader.bind(d),r.geometry.bind(e),this.state.blendMode=i.correctBlendMode(t.blendMode,s.alphaMode),r.state.set(this.state),r.geometry.draw(this.renderer.gl.TRIANGLES,6,0)},e}(r.ObjectRenderer);return t.TilingSprite=s,t.TilingSpriteRenderer=d,t}({},PIXI,PIXI,PIXI.utils,PIXI,PIXI);Object.assign(this.PIXI,_pixi_sprite_tiling);
//# sourceMappingURL=sprite-tiling.min.js.map
