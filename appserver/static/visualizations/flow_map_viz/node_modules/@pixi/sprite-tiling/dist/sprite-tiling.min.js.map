{"version":3,"file":"sprite-tiling.min.js","sources":["../src/TilingSprite.js","../src/TilingSpriteRenderer.js"],"sourcesContent":["import { TextureMatrix, Texture } from '@pixi/core';\nimport { Point, Rectangle, Transform } from '@pixi/math';\nimport { TextureCache } from '@pixi/utils';\nimport { Sprite } from '@pixi/sprite';\n\nconst tempPoint = new Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\nexport class TilingSprite extends Sprite\n{\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    constructor(texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.Transform}\n         */\n        this.tileTransform = new Transform();\n\n        // /// private\n\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._width = width;\n\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._height = height;\n\n        /**\n         * Canvas pattern\n         *\n         * @type {CanvasPattern}\n         * @private\n         */\n        this._canvasPattern = null;\n\n        /**\n         * matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space\n         *\n         * @member {PIXI.TextureMatrix}\n         */\n        this.uvMatrix = texture.uvMatrix || new TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_render' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        /**\n         * Whether or not anchor affects uvs\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this.uvMatrix.clampMargin;\n    }\n\n    set clampMargin(value) // eslint-disable-line require-jsdoc\n    {\n        this.uvMatrix.clampMargin = value;\n        this.uvMatrix.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tileScale()\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.scale.copyFrom(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tilePosition()\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.position.copyFrom(value);\n    }\n\n    /**\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        if (this.uvMatrix)\n        {\n            this.uvMatrix.texture = this._texture;\n        }\n        this._cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _render(renderer)\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvMatrix.update();\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @protected\n     */\n    _calculateBounds()\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.Point} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvMatrix = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.TilingSprite} The newly created texture\n     */\n    static from(source, width, height)\n    {\n        return new TilingSprite(Texture.from(source), width, height);\n    }\n\n    /**\n     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n     */\n    static fromFrame(frameId, width, height)\n    {\n        const texture = TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache ${this}`);\n        }\n\n        return new TilingSprite(texture, width, height);\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture based on an image url\n     * If the image is not in the texture cache it will be loaded\n     *\n     * @static\n     * @param {string} imageId - The image url of the texture\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @param {Object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @return {PIXI.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n     */\n    static fromImage(imageId, width, height, options)\n    {\n        // Fallback support for crossorigin, scaleMode parameters\n        if (options && typeof options !== 'object')\n        {\n            options = {\n                scaleMode: arguments[4],\n                resourceOptions: {\n                    crossorigin: arguments[3],\n                },\n            };\n        }\n\n        return new TilingSprite(Texture.from(imageId, options), width, height);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this._height = value;\n    }\n}\n","import { ObjectRenderer, Shader, State, QuadUv } from '@pixi/core';\nimport { WRAP_MODES } from '@pixi/constants';\nimport { Matrix } from '@pixi/math';\nimport { premultiplyTintToRgba, correctBlendMode } from '@pixi/utils';\n\nimport vertex from './tilingSprite.vert';\nimport fragment from './tilingSprite.frag';\nimport fragmentSimple from './tilingSprite_simple.frag';\n\nconst tempMat = new Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport class TilingSpriteRenderer extends ObjectRenderer\n{\n    /**\n     * constructor for renderer\n     *\n     * @param {PIXI.Renderer} renderer The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        const uniforms = { globals: this.renderer.globalUniforms };\n\n        this.shader = Shader.from(vertex, fragment, uniforms);\n\n        this.simpleShader = Shader.from(vertex, fragmentSimple, uniforms);\n\n        this.quad = new QuadUv();\n\n        /**\n         * The WebGL state in which this renderer will work.\n         *\n         * @member {PIXI.State}\n         * @readonly\n         */\n        this.state = State.for2d();\n    }\n\n    /**\n     *\n     * @param {PIXI.TilingSprite} ts tilingSprite to be rendered\n     */\n    render(ts)\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        if (ts.uvRespectAnchor)\n        {\n            vertices = quad.uvs;\n\n            vertices[0] = vertices[6] = -ts.anchor.x;\n            vertices[1] = vertices[3] = -ts.anchor.y;\n\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n        }\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, baseTex.alphaMode);\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);// , renderer.shader.getGLShader());\n\n        this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n"],"names":["const","tempPoint","Point","TilingSprite","texture","width","height","super","this","tileTransform","Transform","_width","_height","_canvasPattern","uvMatrix","TextureMatrix","pluginName","uvRespectAnchor","prototypeAccessors","clampMargin","value","update","tileScale","scale","copyFrom","tilePosition","position","_onTextureUpdate","_texture","_cachedTint","_render","renderer","valid","updateLocalTransform","batch","setObjectRenderer","plugins","render","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","transform","getLocalBounds","rect","children","length","_localBoundsRect","Rectangle","getRectangle","call","containsPoint","point","worldTransform","applyInverse","x1","anchor","x","y1","y","destroy","options","from","source","Texture","fromFrame","frameId","TextureCache","Error","fromImage","imageId","scaleMode","arguments","resourceOptions","crossorigin","Sprite","tempMat","Matrix","TilingSpriteRenderer","uniforms","globals","globalUniforms","shader","Shader","vertex","fragment","simpleShader","fragmentSimple","quad","QuadUv","state","State","for2d","ts","vertices","uvs","invalidate","tex","baseTex","baseTexture","lt","localTransform","uv","isSimple","isPowerOfTwo","frame","_glTextures","CONTEXT_UID","wrapMode","WRAP_MODES","CLAMP","REPEAT","w","h","W","H","set","a","b","c","d","tx","ty","invert","prepend","mapCoord","uMapCoord","toArray","uClampFrame","uClampOffset","uTransform","uColor","premultiplyTintToRgba","tint","worldAlpha","alphaMode","translationMatrix","uSampler","bind","geometry","blendMode","correctBlendMode","draw","gl","TRIANGLES","ObjectRenderer"],"mappings":"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"}