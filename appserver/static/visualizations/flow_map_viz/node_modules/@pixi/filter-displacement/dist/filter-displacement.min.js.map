{"version":3,"file":"filter-displacement.min.js","sources":["../src/DisplacementFilter.js"],"sourcesContent":["import { Filter } from '@pixi/core';\nimport { Matrix, Point } from '@pixi/math';\nimport vertex from './displacement.vert';\nimport fragment from './displacement.frag';\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object.\n *\n * You can use this filter to apply all manor of crazy warping effects.\n * Currently the `r` property of the texture is used to offset the `x`\n * and the `g` property of the texture is used to offset the `y`.\n *\n * The way it works is it uses the values of the displacement map to look up the\n * correct pixels to output. This means it's not technically moving the original.\n * Instead, it's starting at the output and asking \"which pixel from the original goes here\".\n * For example, if a displacement map pixel has `red = 1` and the filter scale is `20`,\n * this filter will output the pixel approximately 20 pixels to the right of the original.\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n */\nexport class DisplacementFilter extends Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n     * @param {number} [scale] - The scale of the displacement\n     */\n    constructor(sprite, scale)\n    {\n        const maskMatrix = new Matrix();\n\n        sprite.renderable = false;\n\n        super(vertex, fragment, {\n            mapSampler: sprite._texture,\n            filterMatrix: maskMatrix,\n            scale: { x: 1, y: 1 },\n            rotation: new Float32Array([1, 0, 0, 1]),\n        });\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n\n        if (scale === null || scale === undefined)\n        {\n            scale = 20;\n        }\n\n        /**\n         * scaleX, scaleY for displacements\n         * @member {PIXI.Point}\n         */\n        this.scale = new Point(scale, scale);\n    }\n\n    /**\n     * Applies the filter.\n     *\n     * @param {PIXI.systems.FilterSystem} filterManager - The manager.\n     * @param {PIXI.RenderTexture} input - The input target.\n     * @param {PIXI.RenderTexture} output - The output target.\n     * @param {boolean} clear - Should the output be cleared before rendering to it.\n     */\n    apply(filterManager, input, output, clear)\n    {\n        // fill maskMatrix with _normalized sprite texture coords_\n        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n        // Extract rotation from world transform\n        const wt = this.maskSprite.transform.worldTransform;\n        const lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));\n        const lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));\n\n        if (lenX !== 0 && lenY !== 0)\n        {\n            this.uniforms.rotation[0] = wt.a / lenX;\n            this.uniforms.rotation[1] = wt.b / lenX;\n            this.uniforms.rotation[2] = wt.c / lenY;\n            this.uniforms.rotation[3] = wt.d / lenY;\n        }\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clear);\n    }\n\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {PIXI.Texture}\n     */\n    get map()\n    {\n        return this.uniforms.mapSampler;\n    }\n\n    set map(value) // eslint-disable-line require-jsdoc\n    {\n        this.uniforms.mapSampler = value;\n    }\n}\n"],"names":["DisplacementFilter","sprite","scale","const","maskMatrix","Matrix","renderable","super","vertex","fragment","mapSampler","_texture","filterMatrix","x","y","rotation","Float32Array","this","maskSprite","Point","apply","filterManager","input","output","clear","uniforms","calculateSpriteMatrix","wt","transform","worldTransform","lenX","Math","sqrt","a","b","lenY","c","d","applyFilter","prototypeAccessors","map","value","Filter"],"mappings":";;;;;;;wzCAuBaA,cAMT,WAAYC,EAAQC,GAEhBC,IAAMC,EAAa,IAAIC,SAEvBJ,EAAOK,YAAa,EAEpBC,YAAMC,EAAQC,EAAU,CACpBC,WAAYT,EAAOU,SACnBC,aAAcR,EACdF,MAAO,CAAEW,EAAG,EAAGC,EAAG,GAClBC,SAAU,IAAIC,aAAa,CAAC,EAAG,EAAG,EAAG,MAGzCC,KAAKC,WAAajB,EAClBgB,KAAKb,WAAaA,EAEdF,MAAAA,IAEAA,EAAQ,IAOZe,KAAKf,MAAQ,IAAIiB,QAAMjB,EAAOA,2IAWlCkB,eAAMC,EAAeC,EAAOC,EAAQC,GAGhCP,KAAKQ,SAASb,aAAeS,EAAcK,sBAAsBT,KAAKb,WAAYa,KAAKC,YACvFD,KAAKQ,SAASvB,MAAMW,EAAII,KAAKf,MAAMW,EACnCI,KAAKQ,SAASvB,MAAMY,EAAIG,KAAKf,MAAMY,EAGnCX,IAAMwB,EAAKV,KAAKC,WAAWU,UAAUC,eAC/BC,EAAOC,KAAKC,KAAML,EAAGM,EAAIN,EAAGM,EAAMN,EAAGO,EAAIP,EAAGO,GAC5CC,EAAOJ,KAAKC,KAAML,EAAGS,EAAIT,EAAGS,EAAMT,EAAGU,EAAIV,EAAGU,GAErC,IAATP,GAAuB,IAATK,IAEdlB,KAAKQ,SAASV,SAAS,GAAKY,EAAGM,EAAIH,EACnCb,KAAKQ,SAASV,SAAS,GAAKY,EAAGO,EAAIJ,EACnCb,KAAKQ,SAASV,SAAS,GAAKY,EAAGS,EAAID,EACnClB,KAAKQ,SAASV,SAAS,GAAKY,EAAGU,EAAIF,GAIvCd,EAAciB,YAAYrB,KAAMK,EAAOC,EAAQC,IAQnDe,EAAIC,mBAEA,OAAOvB,KAAKQ,SAASf,YAGzB6B,EAAIC,iBAAIC,GAEJxB,KAAKQ,SAASf,WAAa+B,6CA9EKC"}